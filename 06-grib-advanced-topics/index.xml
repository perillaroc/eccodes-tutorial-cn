<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>6. 高级话题 on ecCodes教程中文版</title>
    <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/</link>
    <description>Recent content in 6. 高级话题 on ecCodes教程中文版</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    
	<atom:link href="https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Simple Packing</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/simple_packing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/simple_packing/</guid>
      <description>Simple Pakcking 会丢失信息。
keys 基本 key：
 values decimalPrecision changeDecimalPrecision packingError (read only)  仅在明白打包原理的情况下使用下面的 key：
 referenceValue (read only) bitsPerValue decimalScaleFactor binaryScaleFactor (read only)  注意：设置 decimalPrecision 不会重新打包数据，但设置 changeDecimalPrecision 会导致数据重新打包。
simple packing = 离散化 下面的图示说明 simple packing 的原理。
simple packing 的数据值满足下面的公式：
packing error 依赖 packing 参数：
 bitsPerValue decimalScaleFactor binaryScaleFactor referenceValue  Decimal precision 小数精度 = 要保留的小数位数，例如：
decimalPrecision = 0 -&amp;gt; packingError = 0.5
decimalPrecision = 1 -&amp;gt; packingError = 0.</description>
    </item>
    
    <item>
      <title>常数场（Constant fields）</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/constant_fields/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/constant_fields/</guid>
      <description>Constant fields
 如果要素场的所有数值都相等，那么使用常规的 GRIB 消息会将同一个数值重复存储 N 次，效率非常低。
ecCodes 使用常数场保存这种类型的数据，该常数应该是唯一保存的数值，数据段应该为空，因此常数场非常小，并且被精确地编码。
使用如下命令可以创建一个常数场：
grib_set -d 1 in.grib out.grib  常数场中未定义打包参数（packing parameters），即 bitsPerValue=0。
常数场的问题 加载一个常数场：
codes_grib_new_from_file(infile, igrib)  设置一些非常数的数据值：
codes_set(igrib, &#39;values&#39;, values)  注意：此时还不知道打包参数
将消息写入到文件中：
codes_write(igrib, outfile)  我们会得到什么样的 packingError？
因为常数场未设置打包参数，因此 ecCodes 不知道我们需要什么样的小数精度。 一个安全的选择是设置 bitsPerValue = 24。
更好的实践是在设置数值前设置 decimalPrecision 或 bitsPerValue。
codes_grib_new_from_file(infile,igrib) codes_set(igrib,’decimalPrecision’,4) codes_set(igrib,’values’,values) codes_write(igrib,outfile)  codes_grib_new_from_file(infile,igrib) codes_set(igrib,’bitsPerValue’,16) codes_set(igrib,’values’,values) codes_write(igrib,outfile)  练习  创建一个常数 GRIB 文件。
$ grib_set -d 1 t.grib2 c.</description>
    </item>
    
    <item>
      <title>位图</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/bitmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/bitmap/</guid>
      <description>Bitmap
 位图是二进制值的数组，用于表示每个网格点存在或缺失数据。0 值表示着数据缺失（missing），1 值表示数据存在。
为了节省存储，位图用于有效地表示数据段中真实存在的值。
bitmap 尺寸等于网格点的个数（numberOfPoints）。其中：
 0 -&amp;gt; 数据值缺失 1 -&amp;gt; 数据值存在  当编码时，可以使用 misssingValue 告诉库那些数据是缺失的。
默认的缺失值是 9999，但可以被用户修改。例如，使用一个超过正常范围的数值。
库在数据值数组中遇到与缺失值相等的值时，会将该网格点对应的 bitmap 点设为 0.
在解码时，可以直接查询 bitmap 发现缺失的数据。
练习  构造包含 4 个消息的 start.grib2 文件。
构造 4 个 filter 规则
# step0.filter print &amp;quot;message 1&amp;quot;; set bitsPerValue=8; set bitmapPresent=0; set values={0.2, 0.4, 0.6, 0.7, 9999}; write; # step1.filter print &amp;quot;message 2&amp;quot;; set bitsPerValue=16; set bitmapPresent=0; set values={0.2, 0.4, 0.</description>
    </item>
    
    <item>
      <title>多要素场消息</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/multi_field_messages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/multi_field_messages/</guid>
      <description>GRIB 2 的消息中第2段到第7段都可以重复，见下图。
 译者注：NWPC 的 GRIB 2 数据尚未使用该功能，下面示例只是教程中的文字，尚未实际验证。
 一个示例文件如下图所示：
示例 考虑 数值预报模式预报的 12 小时和 24小时的 500 hPa 高度场。
Section 0: Indicator Section Section 1: Identification Section Section 2: Local Use Section (optional) Section 3: Grid Definition Section Section 4: Product Definition Section (hour = 12) | repetition 1 Section 5: Data Representation Section | Section 6: Bit-Map Section | Section 7: Data Section | Section 4: Product Definition Section (hour = 24) | repetition 2 Section 5: Data Representation Section | Section 6: Bit-Map Section | Section 7: Data Section | Section 8: End Section  注意：网格定义段（Grid Definition Section）未重复，对所有的预报时效都有效。</description>
    </item>
    
    <item>
      <title>参数数据库</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/parameter_database/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/parameter_database/</guid>
      <description>GRIB 1 参数（WMO 编码） 10 metre U wind component
indicatorOfParameter = 33 [u-compoment of wind (m/s)]
table2Version = 3
indicatorOfTypeOfLevel = 105 [Specified height level above ground (m)]
level = 10
GRIB 2 参数（WMO 编码） 10 metre U wind component
discipline = 0 [Meteorological products]
parameterCategory = 2 [Monmentum]
parameterNumber = 2 [u-component of wind (m s-1)]
typeOfFirstFixedSurface = 103 [Specified height level above ground (m)]
scaleFactorOfFirstFixedSurface = 0</description>
    </item>
    
    <item>
      <title>GRIB 1 到 2 的转换</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/grib_1_to_2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/grib_1_to_2/</guid>
      <description>grib_set -s edition=2 in.grib1 out.grib2  上述命令会转换如下内容：
 time geography vertical parameter local data  因为两种编码标准各有不同，再加上一些气象中心会使用本地码表，所以参数转换比较复杂。
转换会基于变量参数的唯一标识符 paramId。
基于 paramId 的转换 如何生成 2 米温度的 GRIB 文件：
grib_set -s paramId=165 in.grib1 out.grib1 grib_set -s paramId=165 in.grib2 out.grib2  如何将 GRIB 1 文件转码为 GRIB 2 文件：
grib_set -s edition=2 in.grib1 out.grib2  在转换到版本 2 的过程中，ecCodes 从 GRIB 1 拷贝 paramId 到 GRIB 2：
 从 GRIB 1 中获取 paramId（=165） 修改版本号为 2，生成 GRIB 2 文件 设置 GRIB 2 的 paramId（=165）  转换仅在 paramId 定义了两个版本的情况下可行。</description>
    </item>
    
    <item>
      <title>本地配置</title>
      <link>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/local_configure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://perillaroc.github.io/eccodes-tutorial-cn/06-grib-advanced-topics/local_configure/</guid>
      <description>WMO 强烈建议不要在非本地使用和国际交换的消息中使用本地码表。
定义被解码引擎使用的解码规则的外部文本文件叫做定义文件（definition files）。
安装 ecCodes 会有一个默认的码表文件集合。
设置环境变量 ECCODES_DEFINITION_PATH，使用本地定义文件替代 ecCodes 提供的定义文件。
为给定中心 centre 定义的变量描述包含在 shortName.def，paramId.def，units.def，name.def 等文件中。 这些文件保存在如下目录：
BASE_DIR/definitions/grib1/localConcepts/[centre:s] BASE_DIR/definitions/grib2/localConcepts/[centre:s]  注意：centre:s 是指用字符串表示的 centre，例如 ecmf, kwbc, cnmc 等等。
通用变量描述包含在 shrotName.def，paramId.def，units.def，name.def 文件中，这些定义文件保存在如下目录：
BASE_DIR/definitions/grib1 BASE_DIR/definitions/grib2  环境变量 ECCODES_DEFINITION_PATH ECCODES_DEFINITION_PATH=/my/definitions:/eccodes/definitions  ecCodes 库会首先搜索目录 /my/definitions 中的每个需要的定义文件，然后搜索 /eccodes/definitions 目录下的文件。
如果在 /my/definitions 中找到定义文件，编码引擎就会使用该文件。
用户可以使用自己的定义文件覆盖所有的定义文件。
我们只建议覆盖包含变量信息的定义文件。
定义一个本地变量 使用 codes_info 获取定义文件的目录。
设置环境变量，将 local_dir 添加到目录列表中。
ECCODES_DEFINITION_PATH=local_dir:default_definition_dir  创建下面的目录，用于保存本地定义文件：
local_dir/grib1/localConcepts/[centre:s] local_dir/grib2/localConcepts/[centre:s]  添加文件 shortName.def，paramId.def，name.def 和 units.def。
paramId.def 的示例（GRIB 1）
# Direction of wind waves 500072 = { table2Version = 112; indicatorOfParameter = 101; }  shortName.</description>
    </item>
    
  </channel>
</rss>